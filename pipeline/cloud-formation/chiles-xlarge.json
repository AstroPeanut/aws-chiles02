{
  "AWSTemplateFormatVersion" : "2010-09-09",
  "Description" : "Build a group of EC2 worker instances listening to a SQS queue to run Docker instances",
  "Parameters" : {
    "KeyName" : {
      "Description" : "Name of an existing EC2 KeyPair to enable SSH access to the instance",
      "Type" : "AWS::EC2::KeyPair::KeyName",
      "ConstraintDescription" : "Can contain only ASCII characters."
    },
    "InstanceType" : {
      "Description" : "EC2 instance type",
      "Type" : "String",
      "Default" : "i2.xlarge",
      "AllowedValues" : [
        "i2.xlarge",
        "i2.2xlarge",
        "i2.4xlarge"
      ],
      "ConstraintDescription" : "Must be a valid EC2 instance type"
    },
    "SpotPrice" : {
      "Description" : "Spot price",
      "Type" : "Number",
      "MinValue" : "0.01",
      "MaxValue" : "5.00"
    },
    "DockerPassword" : {
      "Description" : "Docker password",
      "Type" : "String"
    },
    "DfmsId" : {
      "Description" : "DFMS Id",
      "Type" : "String"
    },
    "AmiId" : {
      "Description" : "Which AMI should we use",
      "Type" : "AWS::EC2::Image::Id",
      "ConstraintDescription" : "Must be a valid AMI Id",
      "Default" : "ami-cfed0aaf"
    },
    "MinInstances" : {
      "Description" : "The minimum number of Workers",
      "Type" : "Number",
      "MinValue" : "0",
      "Default"  : "0",
      "ConstraintDescription" : "Enter a number >=0"
    },
    "MaxInstances" : {
      "Description" : "The maximum number of Workers (units of 5)",
      "Type" : "Number",
      "MinValue" : "1",
      "Default"  : "30",
      "ConstraintDescription" : "Enter a number >1"
    },
    "QueueName" : {
      "Description" : "The queue to create",
      "Type" : "String",
      "Default" : "2xlarge",
      "AllowedValues" : [
        "xlarge",
        "2xlarge",
        "4xlarge"
      ],
      "ConstraintDescription" : "Must be a valid EC2 instance type"
    }
  },
  "Resources" : {
    "WorkerSecurityGroup" : {
      "Type" : "AWS::EC2::SecurityGroup",
      "Properties" : {
        "GroupDescription" : "Enable SSH access via port 22",
        "VpcId" : "vpc-9e6622fb",
        "SecurityGroupIngress" : [
          {
            "IpProtocol" : "tcp",
            "FromPort" : "22",
            "ToPort" : "22",
            "CidrIp" : "0.0.0.0/0"
          },
          {
            "IpProtocol" : "tcp",
            "FromPort" : "8000",
            "ToPort" : "8000",
            "CidrIp" : "0.0.0.0/0"
          }
        ]
      }
    },
    "CfnUser" : {
      "Type" : "AWS::IAM::User",
      "Properties" : {
        "Path" : "/",
        "Policies" : [
          {
            "PolicyName" : "Admin",
            "PolicyDocument" : {
              "Statement" : [
                {
                  "Effect" : "Allow",
                  "Action" : "*",
                  "Resource" : "*"
                }
              ]
            }
          }
        ]
      }
    },
    "HostKeys" : {
      "Type" : "AWS::IAM::AccessKey",
      "Properties" : {
        "UserName" : {
          "Ref" : "CfnUser"
        }
      }
    },
    "InputQueue" : {
      "Type" : "AWS::SQS::Queue",
      "Properties" : {
        "MessageRetentionPeriod" : 1209600,
        "QueueName" : { "Ref" : "QueueName" }
      }
    },
    "InputQueuePolicy" : {
      "Type" : "AWS::SQS::QueuePolicy",
      "DependsOn" : "LaunchConfig",
      "Properties" : {
        "Queues" : [ { "Ref" : "InputQueue" } ],
        "PolicyDocument" :  {
          "Version" : "2012-10-17",
          "Id" : "ReadFromQueuePolicy",
          "Statement" : [ {
            "Sid" : "ConsumeMessages",
            "Effect" : "Allow",
            "Principal" : { "AWS" : {"Fn::GetAtt" : ["CfnUser", "Arn"]} },
            "Action" : ["sqs:ReceiveMessage", "sqs:DeleteMessage"],
            "Resource" : { "Fn::GetAtt" : [ "InputQueue", "Arn" ] }
          } ]
        }
      }
    },
    "WorkerGroup" : {
      "Type" : "AWS::AutoScaling::AutoScalingGroup",
      "Properties" : {
        "AvailabilityZones" : {
          "Fn::GetAZs" : ""
        },
        "LaunchConfigurationName" : {
          "Ref" : "LaunchConfig"
        },
        "VPCZoneIdentifier" : [
          "subnet-04e68e73",
          "subnet-bde9a3d8",
          "subnet-628b063b"
        ],
        "MinSize" : { "Ref" : "MinInstances" },
        "MaxSize" : { "Ref" : "MaxInstances" }
      }
    },
    "LaunchConfig" : {
      "Type" : "AWS::AutoScaling::LaunchConfiguration",
      "Metadata" : {
        "Comment" : "Install a simple python application",
        "AWS::CloudFormation::Init" : {
          "config" : {
            "packages" : {
              "yum" : {
                "htop" : [],
                "sysstat" : [],
                "iotop" : []
              }
            }
          }
        }
      },
      "Properties" : {
        "ImageId" : {
          "Ref" : "AmiId"
        },
        "AssociatePublicIpAddress" : "true",
        "BlockDeviceMappings" : {
          "Fn::FindInMap" : [
            "EphemeralDisks",
            { "Ref": "InstanceType" },
            "BlockDeviceMappings"
          ]
        },
        "SpotPrice" : {
          "Ref" : "SpotPrice"
        },
        "InstanceType" : {
          "Ref" : "InstanceType"
        },
        "SecurityGroups" : [
          { "Ref" : "WorkerSecurityGroup" }
        ],
        "KeyName" : {
          "Ref" : "KeyName"
        },
        "UserData" : {
          "Fn::Base64" : {
            "Fn::Join" : [
              "",
              [
                "#!/bin/bash -ve\n",
                "yum -y update\n",

                "# Run cfn-init\n",
                "/opt/aws/bin/cfn-init -v ",
                "         --stack ",
                { "Ref" : "AWS::StackName" },
                "         --resource LaunchConfig ",
                "         --region ",
                { "Ref" : "AWS::Region" },
                "\n",
                "# Print into the logs the disk free\n",
                "\n",
                "df -h\n",
                "\n",
                "if [ -b \"/dev/xvdb\" ]; then\n",
                "\n",
                "    METADATA_URL_BASE=\"http://169.254.169.254/latest\"\n",
                "\n",
                "    yum -y -d0 install mdadm curl\n",
                "\n",
                "    # Configure Raid if needed - taking into account xvdb or sdb\n",
                "    root_drive=`df -h | grep -v grep | awk 'NR==2{print $1}'`\n",
                "\n",
                "    if [ \"$root_drive\" == \"/dev/xvda1\" ]; then\n",
                "      echo \"Detected 'xvd' drive naming scheme (root: $root_drive)\"\n",
                "      DRIVE_SCHEME='xvd'\n",
                "    else\n",
                "      echo \"Detected 'sd' drive naming scheme (root: $root_drive)\"\n",
                "      DRIVE_SCHEME='sd'\n",
                "    fi\n",
                "\n",
                "    # figure out how many ephemerals we have by querying the metadata API, and then:\n",
                "    #  - convert the drive name returned from the API to the hosts DRIVE_SCHEME, if necessary\n",
                "    #  - verify a matching device is available in /dev/\n",
                "    drives=\"\"\n",
                "    ephemeral_count=0\n",
                "    ephemerals=$(curl --silent $METADATA_URL_BASE/meta-data/block-device-mapping/ | grep ephemeral)\n",
                "    for e in $ephemerals; do\n",
                "      echo \"Probing $e ..\"\n",
                "      device_name=$(curl --silent $METADATA_URL_BASE/meta-data/block-device-mapping/$e)\n",
                "      # might have to convert 'sdb' -> 'xvdb'\n",
                "      device_name=$(echo $device_name | sed \"s/sd/$DRIVE_SCHEME/\")\n",
                "      device_path=\"/dev/$device_name\"\n",
                "\n",
                "      # test that the device actually exists since you can request more ephemeral drives than are available\n",
                "      # for an instance type and the meta-data API will happily tell you it exists when it really does not.\n",
                "      if [ -b $device_path ]; then\n",
                "        echo \"Detected ephemeral disk: $device_path\"\n",
                "        drives=\"$drives $device_path\"\n",
                "        ephemeral_count=$((ephemeral_count + 1 ))\n",
                "      else\n",
                "        echo \"Ephemeral disk $e, $device_path is not present. skipping\"\n",
                "      fi\n",
                "    done\n",
                "\n",
                "    echo \"ephemeral_count = $ephemeral_count\"\n",
                "    if (( ephemeral_count > 1 )); then\n",
                "        # overwrite first few blocks in case there is a filesystem, otherwise mdadm will prompt for input\n",
                "        for drive in $drives; do\n",
                "          dd if=/dev/zero of=$drive bs=4096 count=1024\n",
                "        done\n",
                "\n",
                "        mdadm --create --verbose /dev/md0 --level=0 -c256 --raid-devices=$ephemeral_count $drives\n",
                "        blockdev --setra 65536 /dev/md0\n",
                "        mkfs.ext4 /dev/md0\n",
                "        mkdir -p /mnt/dfms\n",
                "        mount -t ext4 -o noatime /dev/md0 /mnt/dfms\n",
                "    elif (( ephemeral_count == 1 )); then\n",
                "        if mountpoint -q \"/media/ephemeral0\" ; then\n",
                "            # The ephemeral disk is usually mounted on /media/ephemeral0\n",
                "            rm -f /mnt/dfms\n",
                "            ln -s /media/ephemeral0 /mnt/dfms\n",
                "        else\n",
                "            # The ephemeral disk is not mounted on /media/ephemeral0 so mount it\n",
                "            mkdir -p /mnt/dfms\n",
                "            mkfs.ext4 /dev/xvdb\n",
                "            mount /dev/xvdb /mnt/dfms\n",
                "        fi\n",
                "    else\n",
                "        mkdir -p /mnt/dfms\n",
                "        mkfs.ext4 /dev/xvdb\n",
                "        mount /dev/xvdb /mnt/dfms\n",
                "    fi\n",
                "fi\n",
                "# Print free disk space\n",
                "df -h\n",
                "\n",
                "# Move the docker volumes to the ephemeral drive\n",
                "service docker stop\n",
                "sleep 10\n",
                "rm -rf /var/lib/docker/vfs\n",
                "rm -rf /var/lib/docker/volumes\n",
                "mkdir -p /mnt/dfms/docker-volumes/vfs\n",
                "ln -s /mnt/dfms/docker-volumes/vfs /var/lib/docker/vfs\n",
                "mkdir -p /mnt/dfms/docker-volumes/volumes\n",
                "ln -s /mnt/dfms/docker-volumes/volumes /var/lib/docker/volumes\n",
                "\n",
                "# Create the DFMS root\n",
                "mkdir -p /mnt/dfms/dfms_root\n",
                "\n",
                "chmod -R 0777 /mnt/dfms\n",
                "\n",
                "dd if=/dev/zero of=/mnt/dfms/swapfile bs=1M count=1024\n",
                "mkswap /mnt/dfms/swapfile\n",
                "swapon /mnt/dfms/swapfile\n",
                "chmod 0600 /mnt/dfms/swapfile\n",
                "\n",
                "service docker start\n",
                "sleep 10\n",
                "\n",
                "docker login --email=a@b.com --username=icrar --password=",
                { "Ref" : "DockerPassword" },
                " sdp-docker-registry.icrar.uwa.edu.au:8080\n",
                "\n",
                "# Get the docker containers now to prevent a race condition later\n",
                "docker pull sdp-docker-registry.icrar.uwa.edu.au:8080/kevin/java-s3-copy:latest\n",
                "docker pull sdp-docker-registry.icrar.uwa.edu.au:8080/kevin/chiles02:latest\n",
                "\n",
                "cd /home/ec2-user\n",
                "runuser -l ec2-user -c 'cd /home/ec2-user/dfms && git pull'\n",
                "runuser -l ec2-user -c 'cd /home/ec2-user/dfms && source /home/ec2-user/virtualenv/dfms/bin/activate && python setup.py install'\n",
                "runuser -l ec2-user -c 'cd /home/ec2-user && git clone https://github.com/ICRAR/aws-chiles02.git'\n",
                "\n",
                "\n",
                "\n",
                "\n",
                "\n",
                "runuser -l ec2-user -c 'cd /home/ec2-user/dfms && source /home/ec2-user/virtualenv/dfms/bin/activate && dfmsNM  --rest -v --daemon --dfms-path=/home/ec2-user/aws-chiles02/pipeline --id=",
                { "Ref" : "DfmsId" },
                "'\n"
              ]
            ]
          }
        }
      }
    },
    "WorkerScaleUpPolicy" : {
      "Type" : "AWS::AutoScaling::ScalingPolicy",
      "Properties" : {
        "AdjustmentType" : "ChangeInCapacity",
        "AutoScalingGroupName" : { "Ref" : "WorkerGroup" },
        "Cooldown" : "60",
        "ScalingAdjustment" : "1"
      }
    },
    "WorkerScaleDownPolicy" : {
      "Type" : "AWS::AutoScaling::ScalingPolicy",
      "Properties" : {
        "AdjustmentType" : "ChangeInCapacity",
        "AutoScalingGroupName" : { "Ref" : "WorkerGroup" },
        "Cooldown" : "60",
        "ScalingAdjustment" : "-1"
      }
    },
    "TooManyMessagesAlarm" : {
      "Type" : "AWS::CloudWatch::Alarm",
      "Properties" : {
        "AlarmDescription" : "Scale-Up if queue depth grows beyond 1 messages",
        "Namespace" : "AWS/SQS",
        "MetricName" : "ApproximateNumberOfMessagesVisible",
        "Dimensions" : [{ "Name" : "QueueName", "Value" : { "Fn::GetAtt" : ["InputQueue", "QueueName"] } }],
        "Statistic" : "Sum",
        "Period" : "60",
        "EvaluationPeriods" : "2",
        "Threshold" : "1",
        "ComparisonOperator" : "GreaterThanThreshold",
        "AlarmActions" : [ { "Ref" : "WorkerScaleUpPolicy" } ]
      }
    },
    "NotEnoughMessagesAlarm" : {
      "Type" : "AWS::CloudWatch::Alarm",
      "Properties" : {
        "AlarmDescription" : "Scale-down if there are too many empty polls, indicating there is not enough work",
        "Namespace" : "AWS/SQS",
        "MetricName" : "NumberOfEmptyReceives",
        "Dimensions" : [{ "Name" : "QueueName", "Value" : { "Fn::GetAtt" : ["InputQueue", "QueueName"] } }],
        "Statistic" : "Sum",
        "Period" : "60",
        "EvaluationPeriods" : "5",
        "Threshold" : "3",
        "ComparisonOperator" : "GreaterThanThreshold",
        "AlarmActions" : [ { "Ref" : "WorkerScaleDownPolicy" } ]
      }
    }
  },
  "Mappings" : {
    "EphemeralDisks" : {
      "i2.xlarge" : {
        "BlockDeviceMappings" : [
          {
            "DeviceName" : "/dev/sdb",
            "VirtualName" : "ephemeral0"
          }
        ]
      },
      "i2.2xlarge" : {
        "BlockDeviceMappings" : [
          {
            "DeviceName" : "/dev/sdb",
            "VirtualName" : "ephemeral0"
          },
          {
            "DeviceName" : "/dev/sdc",
            "VirtualName" : "ephemeral1"
          }
        ]
      },
      "i2.4xlarge" : {
        "BlockDeviceMappings" : [
          {
            "DeviceName" : "/dev/sdb",
            "VirtualName" : "ephemeral0"
          },
          {
            "DeviceName" : "/dev/sdc",
            "VirtualName" : "ephemeral1"
          },
          {
            "DeviceName" : "/dev/sdd",
            "VirtualName" : "ephemeral2"
          },
          {
            "DeviceName" : "/dev/sde",
            "VirtualName" : "ephemeral3"
          }
        ]
      }
    }
  },
  "Outputs" : {
    "QueueURL" : {
      "Description" : "URL of input queue",
      "Value" : { "Ref" : "InputQueue" }
    }
  }
}

